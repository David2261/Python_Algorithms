"""1. Создаем переменную, которая будет принимать значение (input) и проверяем, то что введенное значение является числом (int)
2. Создаем  2 цикла (for i in range) 1) с шагом 2 и счет начинается с n+1 => значения передаем в переменную num 2) с шагом 2 и с счетом num => значения передаем в i
3. Создаем функцию, которая будет проверять остаток от деления num на i (num%i) равно 0, то останавливаем функцию. Иначе выводим ответ.
Вот код:
n = int(input('Number: '))
for num in range(2,n + 1 ):
    for i in range(2,num):
        if (num%i==0):
            break
        print(num)
!!!
n = int(input( 'n = ' ) )
k = int(input( 'k = ' ) )
m, rem = divmod( n, k )
res = []
for i in range(rem):
    res.append( m+1 )
for i in range( k-rem ):
    res.append(m)
print( f'Разбиение массива длиной {n} на {k} подмассивов с длинами:' )
print(res)
!!!
Мы должны разделить массив на 2 части. Мы должны сравнить крайний правый элемент с центральным.
Если правый эл. > центр. эл. => список отсортирован и можно вернуть ответ.
Иначе мы должны сравнить крайний левый эл. с центральным.
Алгоритм работаем за O(logN), если много копий элементов массива, то  сложность опускается до O(N), т.к. приходиться искать эл. в обеих половинах
!!!
^[а-яёa-z]*[А-ЯЁA-Z]{1}[а-яёa-z]*$
!!!
В бинаром дереве поиска самое правое значение > текущего, а самое левое значение < текущего, так же нет повторений. Чтобы проверить, что бинарное дерево является бинарным деревом поиска - надо написать рекурсивный алгоритм который проверяет эти три условия.


SELECT * 
FROM companies 
WHERE city_id IN (
    SELECT id 
    FROM cities 
    WHERE country_id IN (
        SELECT id 
        FROM countries 
        WHERE name = 'название')
    ) AND labors > 1000;"""